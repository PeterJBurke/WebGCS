<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Update title -->
    <title>Drone Control Interface v2.63-Desktop-TCP-AckEkf</title>
    <link rel="stylesheet" href="/static/lib/leaflet.css"/>
    <link rel="stylesheet" href="/static/css/style.css"/> <!-- Link to the updated style.css -->
    <style>
        /* Basic layout styles */
        body { display: flex; flex-direction: column; height: 100vh; margin: 0; }
        h1.main-title { background-color: #333; color: #fff; padding: 8px 15px; margin: 0; font-size: 1.2em; flex-shrink: 0; }
        .main-container { display: flex; flex: 1; overflow: hidden; }
        button:disabled, select:disabled { background-color: #cccccc; color: #666666; cursor: not-allowed; opacity: 0.7; }
        .map-controls { position: absolute; top: 10px; left: 50px; z-index: 500; background: rgba(255,255,255,0.8); padding: 5px; border-radius: 4px; border: 1px solid #bbb; }
        .map-controls button { font-size: 11px; padding: 3px 6px; margin-left: 5px; }
        .goto-controls { 
            display: flex; 
            align-items: center; 
            flex-wrap: wrap; 
            gap: 6px; 
        }
        .goto-controls input { 
            flex-grow: 0; /* Don't let inputs grow automatically */
            margin-right: 6px; 
        }
        /* Specific sizes for different fields */
        #goto-lat, #goto-lon { 
            min-width: 120px; 
            width: 120px; 
        }
        #goto-alt { 
            min-width: 50px; 
            width: 50px; 
        }
        /* Create field groups to keep labels with inputs */
        .field-group {
            display: flex;
            align-items: center;
            white-space: nowrap;
            margin-right: 4px;
        }
        .field-group label {
            margin-right: 4px;
        }
        .mode-select-control { margin-left: 10px; }
        .mode-select-control select { padding: 5px; font-size: 0.9em; }
        
        /* Fly To mode styling */
        .mode-toggle.active {
            background-color: #28a745;
            color: white;
        }
        
        /* Add pulsing animation for target marker */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .pulsing {
            animation: pulse 1s infinite ease-in-out;
        }
        
        /* Request buttons styles - horizontal layout */
        .request-controls {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .request-controls button {
            flex: 1;
        }

        /* Add CSS for the target marker to ensure visibility */
        .target-marker {
            filter: drop-shadow(0px 0px 3px rgba(0, 0, 0, 0.5));
            z-index: 1000 !important;
        }
    </style>
</head>
<body>
    <!-- Update title -->
    <h1 class="main-title">Drone Control Interface v2.63-Desktop-TCP-AckEkf</h1>
    <div class="main-container">
        <div class="left-column">
            <!-- PFD Section -->
            <div class="pfd-section">
                 <div id="attitude-indicator-wrapper">
                    <canvas id="attitude-canvas" width="280" height="250"></canvas>
                    <div id="asi-tape-container"><canvas id="asi-canvas" width="60" height="250"></canvas></div>
                    <div id="alt-tape-container"><canvas id="alt-canvas" width="70" height="250"></canvas></div>
                    <div id="arming-status-overlay" class="pfd-overlay">DISARMED</div>
                    <div id="battery-overlay" class="pfd-overlay">Bat: <span id="battery-value">--.-</span>V</div>
                    <div id="mode-overlay" class="pfd-overlay">Mode: <span id="mode-value">------</span></div>
                    <div id="current-overlay" class="pfd-overlay">Cur: <span id="current-value">--.-</span>A</div>
                    <div id="gps-overlay" class="pfd-overlay">GPS: <span id="gps-fix-value">---</span> (<span id="gps-sats-value">0</span>) HDOP:<span id="gps-hdop-value">--.-</span></div>
                    <div id="latlon-overlay" class="pfd-overlay">Lat: <span id="lat-value">--.------</span><br>Lon: <span id="lon-value">--.------</span></div>
                </div>
            </div>

            <div class="info-controls-section">
                <div class="status">
                    <h2>Status</h2>
                    <div class="status-grid">
                        <div class="status-row">
                            <div class="status-item"><strong>Connection:</strong> <span id="status-connection" class="disconnected">Disconnected</span><span id="heartbeat-indicator" class="heartbeat-icon" title="Heartbeat Status">❤️</span></div>
                            <!-- *** ADDED: EKF Status Display Element *** -->
                            <div class="status-item"><strong>EKF Status:</strong> <span id="ekf-status" class="ekf-status ekf-error">INIT</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <!-- Controls section remains unchanged -->
                     <h2>Controls</h2>
                    <div><button id="btn-arm">Arm</button> <button id="btn-disarm">Disarm</button> <button id="btn-takeoff">Takeoff</button> (Alt: <input type="number" id="takeoff-alt" value="5" step="1" min="1" max="1000" style="width:45px"> m) <button id="btn-land">Land</button> <button id="btn-rtl">RTL</button></div>
                    <div class="mode-select-control"><label for="mode-select">Set Mode:</label> <select id="mode-select"><option value="">--Select Mode--</option><option value="STABILIZE">Stabilize</option><option value="ALT_HOLD">Alt Hold</option><option value="POS_HOLD">Pos Hold</option><option value="LOITER">Loiter</option><option value="GUIDED">Guided</option><option value="RTL">RTL</option><option value="LAND">Land</option><option value="AUTO">Auto</option><option value="BRAKE">Brake</option></select> <button id="btn-set-mode">Set</button></div>
                    <hr>
                    <div class="goto-controls">
                        <div class="field-group">
                            <label for="goto-lat">Lat</label>
                            <input type="number" step="any" id="goto-lat" placeholder="[-90,90]">
                        </div>
                        <div class="field-group">
                            <label for="goto-lon">Lon</label>
                            <input type="number" step="any" id="goto-lon" placeholder="[-180,180]">
                        </div>
                        <div class="field-group">
                            <label for="goto-alt">Alt</label>
                            <input type="number" step="any" id="goto-alt" placeholder="AGL" value="10" min="-100" max="5000">
                        </div>
                        <button id="btn-goto">Go To</button>
                        <button id="btn-clear-goto" title="Clear GoTo Fields">Clear</button>
                    </div>
                    <hr>
                    <!-- Add mission and fence request buttons horizontally -->
                    <div class="request-controls">
                        <button id="btn-request-fence">Request Fence</button>
                        <button id="btn-request-mission">Request Mission</button>
                    </div>
                </div>
                
                <!-- Messages section moved to appear after controls -->
                <div class="messages-section">
                    <h2>Messages</h2>
                    <div id="messages" class="message-log"><strong>Messages:</strong><br></div>
                </div>
            </div>
        </div>
        <div class="right-column" id="map">
            <div class="map-controls"> 
                <button id="btn-center-map" title="Center map on drone">Center Map</button>
                <button id="btn-fly-to-mode" title="Click on map to fly the drone to that position" class="mode-toggle">Fly To: OFF</button>
            </div>
        </div>
    </div>
    <a href="/mavlink_dump" id="dump-link-button" target="_blank" title="Open MAVLink Message Dump">Dump</a>

    <script src="/static/lib/leaflet.js"></script>
    <script src="/static/lib/socket.io.min.js"></script>
    <script>
        // --- Global Variables & DOM Elements ---
        const map = L.map('map', {
            maxZoom: 22,  // Increased from default (18)
            minZoom: 2,   // Minimum zoom level
            zoomControl: true,  // Show zoom controls
            zoomDelta: 1,  // Zoom level increment
            zoomSnap: 0.5  // Allow half-step zoom levels
        }).setView([0, 0], 2);
        
        // Base layers
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 22,
            maxNativeZoom: 19
        });

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '© Esri',
            maxZoom: 22,
            maxNativeZoom: 18
        });

        // Define base maps for layer control
        const baseMaps = {
            "Street": osmLayer,
            "Satellite": satelliteLayer
        };

        // Add default layer and layer control with collapsed: false to always show options
        osmLayer.addTo(map);
        L.control.layers(baseMaps, {}, {
            position: 'topright',
            collapsed: false  // Always show the control expanded
        }).addTo(map);
        
        let droneMarker = null, homeMarker = null, firstLocationUpdate = true;
        let flyToTargetMarker = null;
        let currentClickMarker = null; // Track the current green dot
        const droneIcon = L.icon({ iconUrl: 'data:image/svg+xml;base64,'+btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#007bff"><path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/></svg>'), iconSize: [24, 24], iconAnchor: [12, 12] });
        const homeIcon = L.icon({ iconUrl: 'data:image/svg+xml;base64,'+btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#28a745"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8h5z"/></svg>'), iconSize: [24, 24], iconAnchor: [12, 24] });
        const targetIcon = L.icon({ 
            iconUrl: 'data:image/svg+xml;base64,'+btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#ff3b30"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="5"/></svg>'), 
            iconSize: [28, 28], 
            iconAnchor: [14, 14],
            className: 'target-marker' // Add class for easier styling/debugging
        });
        const socket = io();
        const messagesDiv = document.getElementById('messages');
        const ahCanvas = document.getElementById('attitude-canvas'), ahCtx = ahCanvas.getContext('2d');
        const asiCanvas = document.getElementById('asi-canvas'), asiCtx = asiCanvas.getContext('2d');
        const altCanvas = document.getElementById('alt-canvas'), altCtx = altCanvas.getContext('2d');
        const armingStatusOverlay = document.getElementById('arming-status-overlay');
        const batteryOverlay = document.getElementById('battery-overlay');
        const modeOverlay = document.getElementById('mode-overlay');
        const currentOverlay = document.getElementById('current-overlay');
        const gpsOverlay = document.getElementById('gps-overlay');
        const latlonOverlay = document.getElementById('latlon-overlay');
        const batteryValueSpan = document.getElementById('battery-value');
        const modeValueSpan = document.getElementById('mode-value');
        const currentValueSpan = document.getElementById('current-value');
        const gpsFixValueSpan = document.getElementById('gps-fix-value');
        const gpsSatsValueSpan = document.getElementById('gps-sats-value');
        const gpsHdopValueSpan = document.getElementById('gps-hdop-value');
        const latValueSpan = document.getElementById('lat-value');
        const lonValueSpan = document.getElementById('lon-value');
        const ekfStatusSpan = document.getElementById('ekf-status');
        const commandControls={ARM:document.getElementById("btn-arm"),DISARM:document.getElementById("btn-disarm"),TAKEOFF:document.getElementById("btn-takeoff"),LAND:document.getElementById("btn-land"),RTL:document.getElementById("btn-rtl"),SET_MODE:document.getElementById("btn-set-mode"),GOTO:document.getElementById("btn-goto"),"clear-goto":document.getElementById("btn-clear-goto"),"center-map":document.getElementById("btn-center-map")};
        const modeSelect=document.getElementById("mode-select");
        const DEG_TO_RAD = Math.PI / 180;
        const RAD_TO_DEG = 180 / Math.PI;
        const M_S_TO_KNOTS = 1.94384;
        const ahWidth = ahCanvas.width, ahHeight = ahCanvas.height;
        const ahCenterX = ahWidth / 2, ahCenterY = ahHeight / 2;
        const PITCH_SCALE_FACTOR = 4;
        const TAPE_WIDTH = asiCanvas.width;
        const TAPE_ALT_WIDTH = altCanvas.width;
        const TAPE_HEIGHT = ahHeight;
        const TAPE_CENTER_Y = TAPE_HEIGHT / 2;
        const ASI_PIXELS_PER_UNIT = 5;
        const ALT_PIXELS_PER_UNIT = 5;
        const HEADING_PIXELS_PER_DEG = 2.5;
        const HEADING_TAPE_HEIGHT = 25;
        const PFD_SKY_COLOR = "#87CEEB";
        const PFD_GROUND_COLOR = "#A0522D";
        const PFD_HORIZON_LINE_COLOR = "#FFFFFF";
        const PFD_AIRCRAFT_SYMBOL_COLOR = "#FFFF00";
        const PFD_TAPE_TICK_COLOR = "#FFFFFF";
        const PFD_TAPE_POINTER_COLOR = "#FFFF00";
        const PFD_OVERLAY_BOX_COLOR = "rgba(50, 50, 50, 0.7)";
        const PFD_OVERLAY_TEXT_COLOR = "#FFFFFF";

        // --- PFD Drawing Functions (drawRoundedRect, drawAttitudeIndicator, drawAirspeedTape, drawAltitudeTape) ---
        function drawRoundedRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.arcTo(x + width, y, x + width, y + radius, radius); ctx.lineTo(x + width, y + height - radius); ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius); ctx.lineTo(x + radius, y + height); ctx.arcTo(x, y + height, x, y + height - radius, radius); ctx.lineTo(x, y + radius); ctx.arcTo(x, y, x + radius, y, radius); ctx.closePath(); }
        function drawAttitudeIndicator(pitch = 0, roll = 0, heading = 0) { const rollRad = -roll * DEG_TO_RAD; const pitchPx = pitch * PITCH_SCALE_FACTOR; const ctx = ahCtx; ctx.save(); ctx.fillStyle = "#000"; ctx.fillRect(0, 0, ahWidth, ahHeight); ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; ctx.fillRect(0, 0, ahWidth, HEADING_TAPE_HEIGHT); ctx.save(); ctx.strokeStyle = PFD_TAPE_TICK_COLOR; ctx.fillStyle = PFD_TAPE_TICK_COLOR; ctx.font = "bold 12px monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.beginPath(); ctx.rect(0, 0, ahWidth, HEADING_TAPE_HEIGHT); ctx.clip(); ctx.translate(ahCenterX - heading * HEADING_PIXELS_PER_DEG, HEADING_TAPE_HEIGHT / 2); const headingRange = Math.ceil(ahWidth / (2 * HEADING_PIXELS_PER_DEG)); const startHdg = Math.floor(heading - headingRange - 10); const endHdg = Math.ceil(heading + headingRange + 10); const headingLabels = { 0: "N", 30: "3", 60: "6", 90: "E", 120: "12", 150: "15", 180: "S", 210: "21", 240: "24", 270: "W", 300: "30", 330: "33", 360: "N" }; for (let h = startHdg; h <= endHdg; h += 5) { const normalizedHdg = (h % 360 + 360) % 360; const xPos = h * HEADING_PIXELS_PER_DEG; let tickHeight = 5; let isLabelTick = false; let label = null; ctx.lineWidth = 1; if (h % 10 === 0) tickHeight = 10; if (h % 30 === 0) { tickHeight = 15; isLabelTick = true; label = (normalizedHdg / 10).toString(); } if (headingLabels[normalizedHdg]) { tickHeight = 15; isLabelTick = true; label = headingLabels[normalizedHdg]; ctx.lineWidth = 1.5; } ctx.beginPath(); ctx.moveTo(xPos, -tickHeight / 2); ctx.lineTo(xPos, tickHeight / 2); ctx.stroke(); if (isLabelTick && label) { ctx.fillText(label, xPos, tickHeight / 2 + 10); } } ctx.restore(); ctx.save(); ctx.beginPath(); ctx.rect(0, HEADING_TAPE_HEIGHT, ahWidth, ahHeight - HEADING_TAPE_HEIGHT); ctx.clip(); ctx.translate(ahCenterX, ahCenterY + HEADING_TAPE_HEIGHT / 2); ctx.rotate(rollRad); ctx.translate(0, pitchPx); ctx.fillStyle = PFD_SKY_COLOR; ctx.fillRect(-ahWidth * 1.5, -ahHeight * 2, ahWidth * 3, ahHeight * 2); ctx.fillStyle = PFD_GROUND_COLOR; ctx.fillRect(-ahWidth * 1.5, 0, ahWidth * 3, ahHeight * 2); ctx.strokeStyle = PFD_HORIZON_LINE_COLOR; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-ahWidth * 1.5, 0); ctx.lineTo(ahWidth * 1.5, 0); ctx.stroke(); ctx.strokeStyle = PFD_HORIZON_LINE_COLOR; ctx.lineWidth = 1; ctx.font = "12px monospace"; ctx.fillStyle = PFD_HORIZON_LINE_COLOR; ctx.textAlign = "center"; const tickLengthShort = 25; const tickLengthLong = 50; for (let p = -90; p <= 90; p += 5) { if (p === 0) continue; const yPos = -p * PITCH_SCALE_FACTOR; if (Math.abs(yPos) > ahHeight * 1.5) continue; const isMajorTick = (p % 10 === 0); const tickLength = isMajorTick ? tickLengthLong : tickLengthShort; ctx.beginPath(); ctx.moveTo(-tickLength / 2, yPos); ctx.lineTo(tickLength / 2, yPos); ctx.stroke(); if (isMajorTick) { ctx.fillText(Math.abs(p).toString(), -tickLength / 2 - 20, yPos + 4); ctx.fillText(Math.abs(p).toString(), tickLength / 2 + 20, yPos + 4); } } ctx.restore(); ctx.save(); ctx.translate(ahCenterX, ahCenterY + HEADING_TAPE_HEIGHT / 2); ctx.strokeStyle = PFD_AIRCRAFT_SYMBOL_COLOR; ctx.fillStyle = PFD_AIRCRAFT_SYMBOL_COLOR; ctx.lineWidth = 2; const notchSize = 4; ctx.beginPath(); ctx.moveTo(0, -notchSize / 2); ctx.lineTo(-notchSize, notchSize / 2); ctx.lineTo(notchSize, notchSize / 2); ctx.closePath(); ctx.fillRect(-1,-1,2,2); const wingLength = 40; ctx.beginPath(); ctx.moveTo(-wingLength, 0); ctx.lineTo(-notchSize*1.5, 0); ctx.moveTo(notchSize*1.5, 0); ctx.lineTo(wingLength, 0); ctx.stroke(); ctx.restore(); ctx.save(); const hdgBoxWidth = 80; const hdgBoxHeight = 20; const hdgBoxX = ahCenterX - hdgBoxWidth / 2; const hdgBoxY = 5; const hdgBoxRadius = 5; ctx.fillStyle = PFD_OVERLAY_BOX_COLOR; drawRoundedRect(ctx, hdgBoxX, hdgBoxY, hdgBoxWidth, hdgBoxHeight, hdgBoxRadius); ctx.fill(); ctx.fillStyle = PFD_OVERLAY_TEXT_COLOR; ctx.font = "bold 11px monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(`HDG: ${heading.toFixed(0)}°`, ahCenterX, hdgBoxY + hdgBoxHeight / 2); ctx.restore(); ctx.fillStyle = PFD_TAPE_POINTER_COLOR; ctx.beginPath(); ctx.moveTo(ahCenterX, HEADING_TAPE_HEIGHT); ctx.lineTo(ahCenterX - 6, HEADING_TAPE_HEIGHT + 6); ctx.lineTo(ahCenterX + 6, HEADING_TAPE_HEIGHT + 6); ctx.closePath(); ctx.fill(); ctx.restore(); }
        function drawAirspeedTape(speed = 0) { const ctx = asiCtx; const tapeWidth = TAPE_WIDTH; const tapeHeight = TAPE_HEIGHT; const centerY = TAPE_CENTER_Y; const pixelsPerUnit = ASI_PIXELS_PER_UNIT; const pointerWidth = 15; ctx.save(); ctx.clearRect(0, 0, tapeWidth, tapeHeight); const pointerBoxHeight = 20; const pointerBoxY = centerY - pointerBoxHeight / 2; const textBoxX = 5; const textBoxWidth = tapeWidth - pointerWidth - 10; ctx.strokeStyle = PFD_TAPE_POINTER_COLOR; ctx.lineWidth = 1.5; ctx.strokeRect(textBoxX, pointerBoxY, textBoxWidth, pointerBoxHeight); ctx.fillStyle = PFD_TAPE_POINTER_COLOR; ctx.font = "bold 14px monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(speed.toFixed(0), textBoxX + textBoxWidth / 2, centerY); ctx.fillStyle = PFD_TAPE_POINTER_COLOR; ctx.beginPath(); ctx.moveTo(tapeWidth - pointerWidth, pointerBoxY); ctx.lineTo(tapeWidth, centerY); ctx.lineTo(tapeWidth - pointerWidth, pointerBoxY + pointerBoxHeight); ctx.closePath(); ctx.fill(); ctx.translate(0, centerY + speed * pixelsPerUnit); ctx.strokeStyle = PFD_TAPE_TICK_COLOR; ctx.fillStyle = PFD_TAPE_TICK_COLOR; ctx.font = "12px monospace"; ctx.textAlign = "right"; ctx.textBaseline = "middle"; const range = Math.ceil(tapeHeight / (2 * pixelsPerUnit * 5)) * 5; const startValue = Math.max(0, Math.floor(speed - range) - 5); const endValue = Math.ceil(speed + range) + 10; for (let val = startValue; val <= endValue; val += 1) { const yPos = -val * pixelsPerUnit; if (yPos < -centerY - 20 || yPos > tapeHeight - centerY + 20) continue; let tickLength = 0; let isLabelTick = false; ctx.lineWidth = 1; if (val % 10 === 0) { tickLength = 15; isLabelTick = true; ctx.lineWidth = 1.5; } else if (val % 5 === 0) { tickLength = 10; } else { tickLength = 5; } if (tickLength > 0) { ctx.beginPath(); ctx.moveTo(0, yPos); ctx.lineTo(tickLength, yPos); ctx.stroke(); if (isLabelTick && val >= 0) { ctx.fillText(val.toString(), -5, yPos); } } } ctx.restore(); }
        function drawAltitudeTape(alt = 0) { const ctx = altCtx; const tapeWidth = TAPE_ALT_WIDTH; const tapeHeight = TAPE_HEIGHT; const centerY = TAPE_CENTER_Y; const pixelsPerUnit = ALT_PIXELS_PER_UNIT; const pointerWidth = 15; ctx.save(); ctx.clearRect(0, 0, tapeWidth, tapeHeight); const pointerBoxHeight = 20; const pointerBoxY = centerY - pointerBoxHeight / 2; const textBoxX = pointerWidth + 5; const textBoxWidth = tapeWidth - pointerWidth - 10; ctx.strokeStyle = PFD_TAPE_POINTER_COLOR; ctx.lineWidth = 1.5; ctx.strokeRect(textBoxX, pointerBoxY, textBoxWidth, pointerBoxHeight); ctx.fillStyle = PFD_TAPE_POINTER_COLOR; ctx.font = "bold 14px monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(alt.toFixed(0), textBoxX + textBoxWidth / 2, centerY); ctx.fillStyle = PFD_TAPE_POINTER_COLOR; ctx.beginPath(); ctx.moveTo(pointerWidth, pointerBoxY); ctx.lineTo(0, centerY); ctx.lineTo(pointerWidth, pointerBoxY + pointerBoxHeight); ctx.closePath(); ctx.fill(); ctx.translate(0, centerY + alt * pixelsPerUnit); ctx.strokeStyle = PFD_TAPE_TICK_COLOR; ctx.fillStyle = PFD_TAPE_TICK_COLOR; ctx.font = "12px monospace"; ctx.textAlign = "left"; ctx.textBaseline = "middle"; const range = Math.ceil(tapeHeight / (2 * pixelsPerUnit * 10)) * 10; const startValue = Math.floor(alt - range) - 10; const endValue = Math.ceil(alt + range) + 20; for (let val = startValue; val <= endValue; val += 2) { const yPos = -val * pixelsPerUnit; if (yPos < -centerY - 20 || yPos > tapeHeight - centerY + 20) continue; let tickLength = 0; let isLabelTick = false; ctx.lineWidth = 1; if (val % 100 === 0) { tickLength = 20; isLabelTick = true; ctx.lineWidth = 2; } else if (val % 20 === 0) { tickLength = 15; isLabelTick = true; ctx.lineWidth = 1.5; } else if (val % 10 === 0) { tickLength = 10; } else if (val % 2 === 0) { tickLength = 5;} if (tickLength > 0) { ctx.beginPath(); ctx.moveTo(tapeWidth, yPos); ctx.lineTo(tapeWidth - tickLength, yPos); ctx.stroke(); if (isLabelTick) { ctx.fillText(val.toString(), tapeWidth - tickLength - 25, yPos); } } } ctx.restore(); }

        // --- Utility Functions ---
        function addMessage(text, type = "info") { const p = document.createElement("p"); const timestamp = new Date().toLocaleTimeString(); p.textContent = `[${timestamp}] ${text}`; p.className = `msg-${type}`; messagesDiv.appendChild(p); messagesDiv.scrollTop = messagesDiv.scrollHeight; while (messagesDiv.children.length > 150) { messagesDiv.removeChild(messagesDiv.children[1]); } }
        function setControlsDisabled(disabled) { Object.values(commandControls).forEach(control => { if (control) control.disabled = disabled; }); if (modeSelect) modeSelect.disabled = disabled; const inputs = document.querySelectorAll('.controls input, .controls select'); inputs.forEach(input => input.disabled = disabled); if (modeSelect && !disabled) modeSelect.disabled = false; }

        // --- SocketIO Event Handlers ---
        socket.on("connect", () => { 
            console.log("Socket Connected"); 
            addMessage("Connected to backend.", "info"); 
            document.getElementById("status-connection").textContent = "Backend Connected"; 
            document.getElementById("status-connection").className = "connected"; 
        });
        
        socket.on("disconnect", () => { 
            console.log("Socket Disconnected"); 
            addMessage("Disconnected from backend.", "error"); 
            document.getElementById("status-connection").textContent = "Disconnected"; 
            document.getElementById("status-connection").className = "disconnected"; 
            armingStatusOverlay.textContent = "DISARMED"; 
            armingStatusOverlay.classList.remove("pfd-armed"); 
            batteryValueSpan.textContent = "--.-"; 
            modeValueSpan.textContent = "------"; 
            currentValueSpan.textContent = "--.-"; 
            gpsFixValueSpan.textContent = "---"; 
            gpsSatsValueSpan.textContent = "0"; 
            gpsHdopValueSpan.textContent = "--.-"; 
            latValueSpan.textContent = "--.------"; 
            lonValueSpan.textContent = "--.------"; 
            const heartIconDisc = document.getElementById('heartbeat-indicator'); 
            if(heartIconDisc) heartIconDisc.classList.remove('connected-state'); 
            ekfStatusSpan.textContent = 'N/A'; 
            ekfStatusSpan.className = 'ekf-status ekf-error'; 
            drawAttitudeIndicator(0, 0, 0); 
            drawAirspeedTape(0); 
            drawAltitudeTape(0); 
            setControlsDisabled(true); 
        });
        
        socket.on("connect_error", (err) => { 
            console.error("Socket Connection Error:", err); 
            addMessage(`Backend connection error: ${err.message}`, "error"); 
            document.getElementById("status-connection").textContent = "Connect Error"; 
            document.getElementById("status-connection").className = "disconnected"; 
            const heartIconErr = document.getElementById('heartbeat-indicator'); 
            if(heartIconErr) heartIconErr.classList.remove('connected-state'); 
            ekfStatusSpan.textContent = 'ERROR'; 
            ekfStatusSpan.className = 'ekf-status ekf-error'; 
            setControlsDisabled(true); 
        });
        
        socket.on("status_message", (data) => { 
            console.log("Status Msg:", data.text, "Type:", data.type); 
            addMessage(data.text, data.type); 
        });

        socket.on("telemetry_update", (state) => {
            console.log("Telemetry update received:", state);
            const isConnected = state.connected;
            document.getElementById("status-connection").textContent = isConnected ? "Drone Connected" : "Drone Disconnected";
            document.getElementById("status-connection").className = isConnected ? "connected" : "disconnected";
            setControlsDisabled(!isConnected);

            const heartIconElement = document.getElementById('heartbeat-indicator');
            if (heartIconElement) { heartIconElement.classList.toggle('connected-state', isConnected); }

            // Update EKF Status Display
            const ekfReport = state.ekf_status_report || 'N/A';
            if (ekfStatusSpan) {
                ekfStatusSpan.textContent = ekfReport;
                ekfStatusSpan.className = 'ekf-status '; // Reset classes
                if (ekfReport === 'EKF OK') {
                    ekfStatusSpan.classList.add('ekf-ok');
                } else if (ekfReport.includes('INIT') || ekfReport.includes('N/A') || ekfReport.includes('ERROR')) {
                     ekfStatusSpan.classList.add('ekf-error');
                } else { // Treat other non-OK statuses as warnings
                    ekfStatusSpan.classList.add('ekf-warn');
                }
            }

            // Update text overlays
            const mode = (state.mode || "UNKNOWN").toUpperCase(); 
            const voltage = state.battery_voltage || 0; 
            const current = state.battery_current ?? -1; 
            const armed = state.armed || false; 
            const lat = state.lat ?? 0; 
            const lon = state.lon ?? 0; 
            const fix = state.gps_fix_type ?? 0; 
            const sats = state.satellites_visible ?? 0; 
            const hdop = state.hdop ?? 99.9; 
            
            console.log("Updating display values:", {
                mode, voltage, current, armed, 
                lat, lon, fix, sats, hdop
            });
            
            batteryValueSpan.textContent = voltage.toFixed(2); 
            modeValueSpan.textContent = mode; 
            armingStatusOverlay.textContent = armed ? "ARMED" : "DISARMED"; 
            armingStatusOverlay.classList.toggle("pfd-armed", armed); 
            currentValueSpan.textContent = current >= 0 ? current.toFixed(1) : "--.-"; 
            let fixStr = "---"; 
            switch (fix) { 
                case 0: case 1: fixStr = "NO"; break; 
                case 2: fixStr = "2D"; break; 
                case 3: fixStr = "3D"; break; 
                case 4: fixStr = "DGPS"; break; 
                case 5: fixStr = "RTKf"; break; 
                case 6: fixStr = "RTKx"; break; 
                default: fixStr = `?${fix}`; 
            } 
            gpsFixValueSpan.textContent = fixStr; 
            gpsSatsValueSpan.textContent = sats >= 0 ? sats : "?"; 
            gpsHdopValueSpan.textContent = hdop < 99 ? hdop.toFixed(1) : "--.-"; 
            latValueSpan.textContent = lat.toFixed(7); 
            lonValueSpan.textContent = lon.toFixed(7);

            // Update PFD canvas drawings
            const airspeed = state.airspeed || 0; 
            const altRel = state.alt_rel || 0; 
            const heading = state.heading || 0; 
            const pitch = (state.pitch || 0) * RAD_TO_DEG; 
            const roll = (state.roll || 0) * RAD_TO_DEG;
            
            console.log("Updating PFD values:", {
                airspeed, altRel, heading,
                pitch: pitch.toFixed(1), 
                roll: roll.toFixed(1)
            });
            
            drawAttitudeIndicator(pitch, roll, heading); 
            drawAirspeedTape(airspeed); 
            drawAltitudeTape(altRel);

            // Update Map
            if (isConnected && lat != null && lon != null && lat !== 0 && lon !== 0) { 
                const latLng = [lat, lon]; 
                if (!droneMarker) { 
                    droneMarker = L.marker(latLng, { icon: droneIcon }).addTo(map).bindPopup("Drone Position"); 
                } else { 
                    droneMarker.setLatLng(latLng); 
                } 
                if (firstLocationUpdate) { 
                    map.setView(latLng, 16); 
                    firstLocationUpdate = false; 
                } 
            } else { 
                if (droneMarker) { 
                    map.removeLayer(droneMarker); 
                    droneMarker = null; 
                    firstLocationUpdate = true; 
                } 
            } 
            
            const homeLat = state.home_lat; 
            const homeLon = state.home_lon; 
            
            if (isConnected && homeLat != null && homeLon != null && homeLat !== 0 && homeLon !== 0) { 
                const homeLatLng = [homeLat, homeLon]; 
                if (!homeMarker) { 
                    homeMarker = L.marker(homeLatLng, { icon: homeIcon }).addTo(map).bindPopup("Home Position"); 
                } else { 
                    homeMarker.setLatLng(homeLatLng); 
                } 
            } else { 
                if (homeMarker) { 
                    map.removeLayer(homeMarker); 
                    homeMarker = null; 
                } 
            } 
            
            try{ 
                map.invalidateSize(); 
            } catch(e) {/*ignore*/}
        });

        // --- Command Button Event Listeners ---
        commandControls.ARM.addEventListener("click",function(){if(confirm("ARM drone?")){this.disabled=!0;socket.emit("send_command",{command:"ARM"})}});
        commandControls.DISARM.addEventListener("click",function(){if(confirm("DISARM drone?")){this.disabled=!0;socket.emit("send_command",{command:"DISARM"})}});
        commandControls.TAKEOFF.addEventListener("click",function(){const e=document.getElementById("takeoff-alt"),t=parseFloat(e.value);if(isNaN(t)||t<=0||t>1e3)return addMessage("Invalid takeoff altitude (must be > 0 and <= 1000).","warning"),void e.focus();if(confirm(`Takeoff to ${t}m?`)){this.disabled=!0;socket.emit("send_command",{command:"TAKEOFF",altitude:t})}});
        commandControls.LAND.addEventListener("click",function(){if(confirm("LAND drone?")){this.disabled=!0;socket.emit("send_command",{command:"LAND"})}});
        commandControls.RTL.addEventListener("click",function(){if(confirm("Return-To-Launch (RTL)?")){this.disabled=!0;socket.emit("send_command",{command:"RTL"})}});
        commandControls.SET_MODE.addEventListener("click",function(){const e=modeSelect.value;if(!e)return void addMessage("Please select a flight mode.","warning");if(confirm(`Set mode to ${e}?`)){this.disabled=!0;modeSelect.disabled=!0;socket.emit("send_command",{command:"SET_MODE",mode_string:e})}});
        commandControls.GOTO.addEventListener("click",function(){const e=document.getElementById("goto-lat"),t=document.getElementById("goto-lon"),o=document.getElementById("goto-alt"),a=parseFloat(e.value),n=parseFloat(t.value),i=parseFloat(o.value);let s=!0,l="Invalid GoTo parameters: ";if(isNaN(a)||a<-90||a>90){s=!1;l+=" Latitude invalid.";e.focus()}else if(isNaN(n)||n<-180||n>180){s=!1;l+=" Longitude invalid.";t.focus()}else if(isNaN(i)||i<-100||i>5e3){s=!1;l+=" Altitude invalid.";o.focus()}if(!s)return void addMessage(l,"warning");if(confirm(`Go to Lat: ${a.toFixed(6)}, Lon: ${n.toFixed(6)}, Alt: ${i.toFixed(1)}m?`)){this.disabled=!0;socket.emit("send_command",{command:"GOTO",lat:a,lon:n,alt:i})}});
        commandControls["clear-goto"].addEventListener("click",function(){document.getElementById("goto-lat").value="";document.getElementById("goto-lon").value="";document.getElementById("goto-alt").value="10";addMessage("GoTo fields cleared.","info")});
        commandControls["center-map"].addEventListener("click",function(){if(droneMarker){map.setView(droneMarker.getLatLng(),map.getZoom()<14?16:map.getZoom());addMessage("Map centered on drone.","info")}else{addMessage("Drone location not available to center map.","warning")}});
        
        // Add Fly To Mode Functionality
        let flyToModeActive = false;
        const flyToButton = document.getElementById('btn-fly-to-mode');
        
        flyToButton.addEventListener('click', function() {
            flyToModeActive = !flyToModeActive;
            this.textContent = flyToModeActive ? 'Fly To: ON' : 'Fly To: OFF';
            this.classList.toggle('active', flyToModeActive);
            
            if (flyToModeActive) {
                addMessage("Fly To mode activated. Click on map to send drone to that position.", "info");
                // Change cursor to indicate clickable map
                map._container.style.cursor = 'crosshair';
            } else {
                addMessage("Fly To mode deactivated.", "info");
                // Restore default cursor
                map._container.style.cursor = '';
                
                // Remove any existing target marker when deactivating
                if (flyToTargetMarker) {
                    map.removeLayer(flyToTargetMarker);
                    flyToTargetMarker = null;
                }
            }
        });
        
        // Update map click handler to use a red target icon instead of a green dot
        map.on('click', function(e) {
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            
            console.log("Map clicked at:", lat, lon, "Fly To active:", flyToModeActive);
            
            // Always update the GoTo input fields
            document.getElementById("goto-lat").value = lat.toFixed(7);
            document.getElementById("goto-lon").value = lon.toFixed(7);
            addMessage(`Selected map point: Lat ${lat.toFixed(7)}, Lon ${lon.toFixed(7)}`, "info");
            
            try {
                // Remove previous click marker if it exists
                if (currentClickMarker) {
                    map.removeLayer(currentClickMarker);
                }
                
                // Create a single red target icon at the clicked location
                currentClickMarker = L.marker([lat, lon], {
                    icon: L.divIcon({
                        className: 'click-marker-target',
                        html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20">
                                <circle cx="12" cy="12" r="10" fill="#FF0000" fill-opacity="0.7" stroke="#FFFFFF" stroke-width="1"/>
                                <circle cx="12" cy="12" r="5" fill="#FF0000" fill-opacity="0.9" stroke="#FFFFFF" stroke-width="1"/>
                                <circle cx="12" cy="12" r="2" fill="#FFFFFF"/>
                                <line x1="12" y1="2" x2="12" y2="6" stroke="#FFFFFF" stroke-width="1.5"/>
                                <line x1="12" y1="18" x2="12" y2="22" stroke="#FFFFFF" stroke-width="1.5"/>
                                <line x1="2" y1="12" x2="6" y2="12" stroke="#FFFFFF" stroke-width="1.5"/>
                                <line x1="18" y1="12" x2="22" y2="12" stroke="#FFFFFF" stroke-width="1.5"/>
                              </svg>`,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(map);
                
                console.log("Created new target icon at:", lat, lon);
            } catch (err) {
                console.error("Error creating click marker:", err);
            }
            
            // If Fly To mode is active, handle the marker and command
            if (flyToModeActive) {
                const alt = parseFloat(document.getElementById('goto-alt').value) || 10;
                
                // Remove existing target marker if present
                if (flyToTargetMarker) {
                    map.removeLayer(flyToTargetMarker);
                }
                
                // Create a new marker using the same approach as our working test markers
                flyToTargetMarker = L.circleMarker([lat, lon], {
                    color: '#FF0000',         // Red border
                    fillColor: '#FF0000',     // Red fill
                    fillOpacity: 0.7,         // Semi-transparent
                    radius: 12,               // Size of the circle
                    weight: 3                 // Border thickness
                }).addTo(map);
                
                flyToTargetMarker.bindTooltip(`Target Alt: ${alt.toFixed(1)}m`, {
                    permanent: false,
                    direction: 'top'
                }).openTooltip();
                
                console.log("Created fly-to target marker");
                
                // Confirm before sending command
                if (confirm(`Send drone to Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}, Alt: ${alt.toFixed(1)}m?`)) {
                    // Send the command
                    socket.emit('send_command', {
                        command: 'GOTO',
                        lat: lat,
                        lon: lon,
                        alt: alt
                    });
                    
                    addMessage(`Sent drone to Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}, Alt: ${alt.toFixed(1)}m`, "info");
                }
            }
        });

        // --- Initialisation ---
        function initializeUI() {
            addMessage("Connecting to backend...", "info");
            drawAttitudeIndicator(); drawAirspeedTape(); drawAltitudeTape();
            armingStatusOverlay.textContent = "DISARMED"; armingStatusOverlay.classList.remove("pfd-armed");
            batteryValueSpan.textContent = "--.-"; modeValueSpan.textContent = "------"; currentValueSpan.textContent = "--.-";
            gpsFixValueSpan.textContent = "---"; gpsSatsValueSpan.textContent = "0"; gpsHdopValueSpan.textContent = "--.-";
            latValueSpan.textContent = "--.------"; lonValueSpan.textContent = "--.------";
            // *** ADDED: Initialize heart and EKF status ***
            const heartIconInit = document.getElementById('heartbeat-indicator'); if(heartIconInit) heartIconInit.classList.remove('connected-state');
            if(ekfStatusSpan) { ekfStatusSpan.textContent = 'INIT'; ekfStatusSpan.className = 'ekf-status ekf-error'; }
            setControlsDisabled(true);
            setTimeout(() => { 
                try { 
                    map.invalidateSize(); 
                    
                    // Remove test markers from here - they'll be added in the telemetry update
                    // when we have home position coordinates
                } catch(e) { 
                    console.error("Error on initial invalidateSize:", e); 
                } 
            }, 500);
        }
        initializeUI();

        // *** ADDED: Handle COMMAND_ACK feedback ***
        socket.on("command_ack_received", (data) => {
            console.log("ACK Received:", data);
            let message = `CMD ${data.command_name}: ${data.result_text}`;
            let type = 'ack'; // Default style for generic/in-progress ACKs
            if (data.result === 0) { // MAV_RESULT_ACCEPTED
                type = 'ack'; // Keep blue/default for success
            } else if (data.result === -1) { // Custom: Timeout
                message = `CMD ${data.command_name}: Timeout (No ACK received)`;
                type = 'ack-timeout'; // Yellow/orange for timeout
            } else { // Failed, unsupported, temporarily rejected, etc.
                type = 'ack-fail'; // Red for failure
            }
            addMessage(message, type);
            // Note: Re-enabling buttons on ACK is tricky if multiple commands of the same type are sent quickly.
            // The simple 'command_result' handler might still be needed for basic send failures.
        });

        // Heartbeat animation trigger
        socket.on("mavlink_message", (msg) => {
            if (msg && msg.mavpackettype === 'HEARTBEAT') {
                const heartIcon = document.getElementById('heartbeat-indicator');
                if (heartIcon) {
                    if (!heartIcon.classList.contains('beating')) {
                        heartIcon.classList.add('beating');
                        heartIcon.addEventListener('animationend', () => {
                            heartIcon.classList.remove('beating');
                        }, { once: true });
                    }
                }
            }
        });

        socket.on("command_result", (data) => { 
            console.log("Command Result:", data); 
            if (!data.success) { 
                const control = commandControls[data.command]; 
                if (control) { 
                    control.disabled = false; 
                    if (data.command === 'SET_MODE' && modeSelect) { 
                        modeSelect.disabled = false; 
                    } 
                } 
            } 
        });

        // Add variable to track the geofence polygon
        let geofencePolygon = null;
        let geofenceVertexMarkers = []; // Array to track vertex markers

        // Add variables to track mission waypoints
        let missionPolyline = null;
        let missionWaypointMarkers = []; // Array to track waypoint markers

        socket.on("geofence_update", (data) => {
            // Table has been removed from the UI
            
            if (data && data.points && data.points.length > 0) {
                // Clear existing geofence and markers
                if (geofencePolygon) {
                    map.removeLayer(geofencePolygon);
                }
                
                // Remove existing vertex markers
                geofenceVertexMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
                geofenceVertexMarkers = [];
                
                // Create a polygon from the fence points
                geofencePolygon = L.polygon(data.points, {
                    color: '#0066FF',  // Blue
                    weight: 3,
                    opacity: 0.9,
                    fillOpacity: 0,    // No fill
                    dashArray: null
                }).addTo(map);
                
                // Add blue circles at the vertices
                data.points.forEach((point, index) => {
                    const marker = L.circleMarker(point, {
                        color: '#0066FF',         // Blue border
                        fillColor: '#0066FF',     // Blue fill
                        fillOpacity: 0.7,         // Semi-transparent
                        radius: 5,                // Size of the circle
                        weight: 2                 // Border thickness
                    }).addTo(map)
                    .bindTooltip(`Point ${index + 1}`, {
                        permanent: false,
                        direction: 'top'
                    });
                    
                    // Store marker for later removal
                    geofenceVertexMarkers.push(marker);
                });
                
                // Don't automatically center on the geofence
                // Removed map.fitBounds() call to keep current map view
                
                addMessage("Geofence plotted on map", "info");
            } else {
                // Remove any existing geofence polygon
                if (geofencePolygon) {
                    map.removeLayer(geofencePolygon);
                    geofencePolygon = null;
                }
                
                // Remove existing vertex markers
                geofenceVertexMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
                geofenceVertexMarkers = [];
                
                addMessage("No geofence points available", "warning");
            }
        });

        // Add event listener for geofence request button
        document.getElementById('btn-request-fence').addEventListener('click', function() {
            this.disabled = true;
            socket.emit('send_command', {command: 'REQUEST_FENCE'});
            setTimeout(() => { this.disabled = false; }, 2000);  // Re-enable after 2 seconds
        });

        // Handle mission waypoint updates
        socket.on("mission_update", (data) => {
            if (data && data.waypoints && data.waypoints.length > 0) {
                // Clear existing mission markers and lines
                if (missionPolyline) {
                    map.removeLayer(missionPolyline);
                }
                
                // Remove existing waypoint markers
                missionWaypointMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
                missionWaypointMarkers = [];
                
                // Extract coordinate points for the path 
                const pathPoints = [];
                
                // Create markers for each waypoint
                data.waypoints.forEach((wp, index) => {
                    // Skip waypoints without valid coordinates (like RTL commands)
                    if (wp.lat === 0 && wp.lon === 0) return;
                    
                    // Add point to path if it's a navigation point
                    if (wp.command === 16 || wp.command === 22 || wp.command === 21) { // NAV_WAYPOINT, TAKEOFF, LAND
                        pathPoints.push([wp.lat, wp.lon]);
                    }
                    
                    // Create waypoint icon based on command type
                    let iconColor = '#ff7800'; // Default orange
                    let iconPath = '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>';
                    let tooltipText = `Waypoint ${index + 1}`;
                    
                    // Customize by command type
                    if (wp.command === 22) { // TAKEOFF
                        iconColor = '#28a745'; // Green
                        tooltipText = `Takeoff (${wp.alt.toFixed(1)}m)`;
                        iconPath = '<path d="M2 22h20V10L12 2 2 10v12zm11-1h-4v-5H6.5v-3.5h3V8l4-4 4 4v4.5h3V16H13v5z"/>';
                    } else if (wp.command === 20) { // RETURN_TO_LAUNCH
                        iconColor = '#dc3545'; // Red
                        tooltipText = 'Return to Launch';
                        iconPath = '<path d="M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.41L5.83 13H21V7z"/>';
                    } else if (wp.command === 21) { // LAND
                        iconColor = '#ffc107'; // Yellow/amber
                        tooltipText = 'Land';
                        iconPath = '<path d="M12 7.27l4.28 10.43-3.47-1.53-.81-.36-.81.36-3.47 1.53L12 7.27M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71L12 2z"/>';
                    }
                    
                    // Create custom icon for this waypoint
                    const wpIcon = L.divIcon({
                        className: 'mission-waypoint-icon',
                        html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${iconColor}" width="24px" height="24px">${iconPath}</svg>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    // Add marker with the custom icon
                    const marker = L.marker([wp.lat, wp.lon], {
                        icon: wpIcon
                    }).addTo(map)
                    .bindTooltip(tooltipText, {
                        permanent: false,
                        direction: 'top'
                    });
                    
                    // Store marker for later removal
                    missionWaypointMarkers.push(marker);
                });
                
                // Create a polyline connecting the navigation points
                if (pathPoints.length > 1) {
                    missionPolyline = L.polyline(pathPoints, {
                        color: '#ff7800',  // Orange
                        weight: 3,
                        opacity: 0.8,
                        dashArray: '5, 10' // Dashed line
                    }).addTo(map);
                }
                
                addMessage(`Mission with ${data.waypoints.length} waypoints plotted on map`, "info");
            } else {
                // Clear existing mission
                if (missionPolyline) {
                    map.removeLayer(missionPolyline);
                    missionPolyline = null;
                }
                
                // Remove existing waypoint markers
                missionWaypointMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
                missionWaypointMarkers = [];
                
                addMessage("No mission waypoints available", "warning");
            }
        });

        // Add event listener for mission request button
        document.getElementById('btn-request-mission').addEventListener('click', function() {
            this.disabled = true;
            socket.emit('send_command', {command: 'REQUEST_MISSION'});
            setTimeout(() => { this.disabled = false; }, 2000);  // Re-enable after 2 seconds
        });

    </script>
</body>
</html>
